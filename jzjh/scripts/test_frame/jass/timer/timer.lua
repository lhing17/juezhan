---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by G_Seinfeld.
--- DateTime: 2018/11/5 0005 21:12
---

local timer = {}

local mt = {}
timer.__index = mt

local function UUID()
    local fn = function(x)
        local r = math.random(16) - 1
        r = (x == "x") and (r + 1) or (r % 4) + 9
        return ("0123456789abcdef"):sub(r, r)
    end
    return (("xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx"):gsub("[xy]", fn))
end

function timer.new()
    local t = {}
    t.timers = {}
    return setmetatable(t, timer)
end

function mt:update(dt)
    for tag, timer in pairs(self.timers) do
        timer.time = timer.time + dt
        if timer.type == 'after' then
            if timer.time >= timer.delay then
                timer.action()
                self.timers[tag] = nil
            end
        end
        if timer.type == 'every' then
            if timer.time >= timer.delay then
                timer.action()
                timer.time = timer.time - timer.delay
                timer.delay = self:__getResolvedDelay(timer.any_delay)
                if timer.count > 0 then
                    timer.counter = timer.counter + 1
                    if timer.counter >= timer.count then
                        timer.after()
                        self.timers[tag] = nil
                    end
                end
            end
        end
    end
end

function mt:after(delay, action, tag)
    tag = tag or UUID()
    self:cancel(tag)
    self.timers[tag] = {
        type = 'after',
        time = 0,
        delay = self:__getResolvedDelay(delay),
        action = action
    }
    return tag
end

function mt:every(delay, action, count, after, tag)
    if type(count) == 'string' then
        tag, count = count, 0
    elseif type(count) == 'number' and type(after) == 'string' then
        tag = after
    else
        tag = tag or UUID()
    end
    self:cancel(tag)
    self.timers[tag] = {
        type = 'every',
        time = 0,
        any_delay = delay,
        delay = self:__getResolvedDelay(delay),
        action = action,
        counter = 0,
        count = count or 0,
        after = after or function()
        end,
    }
    return tag
end

function mt:__getResolvedDelay(delay)
    if type(delay) == 'number' then
        return delay
    elseif type(delay) == 'table' then
        return math.random(delay[1], delay[2])
    end
end

function mt:cancel(tag)
    self.timers[tag] = nil
end

function mt:destroy()
    self.timers = {}
end

return setmetatable({}, {__call = function(_, ...) return timer.new(...) end})