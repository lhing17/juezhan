---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by G_Seinfeld.
--- DateTime: 2018/11/1 11:31
---

local common_util = require 'jass.util.common_util'
local mapcontrol = require 'jass.type.mapcontrol'
local playerslotstate = require 'jass.type.playerslotstate'
local playercolor = require 'jass.type.playercolor'

local player = {}
player.all_players = {}

setmetatable(player, player)
local MAX_PLAYER_NUM = 16

local mt = {}
player.__index = mt

-- 是否为观察者
mt.observer = false
mt.id = 0
mt.type = 'player'
mt.name = '玩家1'
mt.team = 1
mt.handicap = 1 -- 障碍
mt.handicap_xp = 1 -- 经验障碍

function mt:set_handicap(handicap)
    self.handicap = handicap
end

function mt:get_handicap()
    return self.handicap
end

function mt:set_handicap_xp(handicap_xp)
    self.handicap_xp = handicap_xp
end

function mt:get_handicap_xp(handicap_xp)
    return self.handicap_xp
end

function mt:get_color()
    return self.color or playercolor[0]
end

function mt:is_ally(p)
    return common_util.is_in_table(p, self.allies)
end

function mt:is_enemy(p)
    return not self:is_ally(p)
end

function mt:is_in_force(f)
    return common_util.is_in_table(p, f.players)
end

function mt:is_observer()
    return self.observer
end

function mt:get_id()
    return self.id
end

function mt:get_unit_count()
    local counter = 0
    for k, v in pairs(self.units) do
        counter = counter + 1
    end
    return counter
end

function mt:get_team()
    return self.team
end

function mt:get_name()
    return self.name
end

function mt:get_controller()
    return self.map_control
end

function mt:get_slot_state()
    return self.slot_state
end

function mt:get_state(state)
    if not self[state] then
        return 0
    end
    return self[state]
end

function mt:set_alliance(p, alliance_type)
    if type(self.allies) == 'table' then
        --FIXME 是否需要分类别
        table.insert(self.allies, p)
    end
end

function mt:set_state(state, value)
    self[state] = value
end

function mt:set_name(name)
    self.name = name
end

function mt:get_tech_count(techid)
    if not self.techs[techid] or not self.techs[techid].level then
        return 0
    end
    return self.techs[techid].level
end

function mt:set_tech_level(techid, level)
    self.techs[techid] = self.techs[techid] or {}
    if self.techs[techid].level and self.techs[techid].level > level then
        return
    end
    self.techs[techid].level = level
end

function mt:is_tech_researched(techid)
    if not self.techs[techid] then
        return false
    end
    return self.techs[techid].level > 0
end

function mt:set_tech_max_allowed(techid, max)
    if not self.techs[techid] then
        self.techs[techid] = {}
    end
    self.techs[techid].max_allowed = max
end

function mt:get_tech_max_allowed(techid)
    if not self.techs[techid] then
        return 100
    end
    return self.techs[techid].max_allowed
end

function mt:set_ability_available(id, flag)
    self.ability_availability[id] = flag
end

function player:__call(i)
    return player[i]
end

function player:__tostring()
    return self.handle_id .. ':' .. self.name
end

function player.get_local()
    if player.native then
        return player.native
    else
        return player[1]
    end
end

function player.init()
    for i = 1, MAX_PLAYER_NUM do
        local p = {}
        p.handle_id = common_util.generate_handle_id()
        p.id = i - 1
        p.units = {}
        setmetatable(p, player)
        player.all_players[p.handle_id] = p
        player[i] = p
        p.allies = {}
        p.techs = {}
        p.ability_availability = {}
        p.color = playercolor[i - 1]
        p.name = '玩家' .. i
        if i <= 5 then
            p.map_control = mapcontrol[0]
            p.team = 1
        else
            p.map_control = mapcontrol[1]
            p.team = 2
        end
        p.slot_state = playerslotstate[1]
    end
    player.native = player[1]
end

return player